#version 150

/*
 * This file is part of the open source part of the
 * Platform for Algorithm Development and Rendering (PADrend).
 * Web page: http://www.padrend.de/
 * Copyright (C) 2016 Claudius Jähn <claudius@uni-paderborn.de>
 * 
 * PADrend consists of an open source part and a proprietary part.
 * The open source part of PADrend is subject to the terms of the Mozilla
 * Public License, v. 2.0. You should have received a copy of the MPL along
 * with this library; see the file LICENSE. If not, you can obtain one at
 * http://mozilla.org/MPL/2.0/.
 */
 
 
 /*
 - Renders points as textured quads
 - The quads are created using a geometry shader
 - Only works for point primitives
 - Add this file as vs-FragmentEffect and gs-Shader to an universal3-shader
 */
 
// ------------------
// vs
#ifdef SG_VERTEX_SHADER

// pass some values to the geomtry shader

out vec3 vertexNormal_cs; 
out vec3 vertexNormal_ms; 
out vec3 vertexPosition_ms; 


struct VertexProperties {
	vec3 position_cs, normal_cs;
	float pointSize;
};

vec3 sg_getVertexPosition_ms();					//!	\see sgHelper.sfn
vec3 sg_getVertexNormal_ms();					//!	\see sgHelper.sfn

//! \see main.sfn
void provideFragmentEffectVars(in VertexProperties vert){ // this is not the intended purpose of this function -- but it works...
	vertexNormal_cs = vert.normal_cs;
	vertexPosition_ms = sg_getVertexPosition_ms();
	vertexNormal_ms = sg_getVertexNormal_ms();
}

#endif

// ------------------
// gs
#ifdef SG_GEOMETRY_SHADER

layout(points) in;
layout(triangle_strip,max_vertices=4) out;

uniform float clusterSize=0.01;
varying vec3 var_normal_cs;
varying vec4 var_vertexColor;
varying vec4 var_position_hcs; // this is NOT set properly!!!
varying vec2 var_texCoord0;

in vec3 vertexNormal_cs[];
in vec3 vertexNormal_ms[];
in vec4 vertexColor[];
in vec3 vertexPosition_ms[];

uniform float sg_time;

vec4 sg_modelToClipping(in vec4 hms);			//!	\see sgHelper.sfn

void main(void) {

	vec3 normal_cs = normalize(vertexNormal_cs[0]);
	vec3 normal_ms = normalize(vertexNormal_ms[0]);

	float s = clusterSize; //*mod(sg_time+normal_ms.x,2.0);

	float rotationAngle = mod(sg_time,3.142*2);

	// rotate the rightVec around normal with rotationAngle
	vec3 rightVec_ms = normalize(cross(normal_ms,vec3(0,1,1))); // use arbitrary tangent vector
	float cosAlpha = cos(rotationAngle);
	float sinAlpha = sin(rotationAngle);
	float f = dot(rightVec_ms,normal_ms)*(1.0-cosAlpha);
	rightVec_ms = vec3( 
		normal_ms.x * f+rightVec_ms.x*cosAlpha+sinAlpha*(normal_ms.y*rightVec_ms.z-normal_ms.z*rightVec_ms.y),
		normal_ms.y * f+rightVec_ms.y*cosAlpha+sinAlpha*(normal_ms.z*rightVec_ms.x-normal_ms.x*rightVec_ms.z),
		normal_ms.z * f+rightVec_ms.z*cosAlpha+sinAlpha*(normal_ms.x*rightVec_ms.y-normal_ms.y*rightVec_ms.x));
	vec3 upVec_ms = normalize(cross(normal_ms,rightVec_ms));
	
	vec4 color = vertexColor[0];
	vec3 position_ms = vertexPosition_ms[0];

	upVec_ms *=s;
	rightVec_ms *=s;

	var_texCoord0 = vec2(0.0, 0.0);
	gl_Position =  sg_modelToClipping(vec4(position_ms-rightVec_ms-upVec_ms,1));
	var_normal_cs = normal_cs;
	var_vertexColor = color;
	var_position_hcs = vec4(0,0,0,1);
	EmitVertex();

	var_texCoord0 = vec2(1.0, 0.0);
	gl_Position = sg_modelToClipping(vec4(position_ms+rightVec_ms-upVec_ms,1));
	var_normal_cs = normal_cs;
	var_vertexColor = color;
	var_position_hcs = vec4(0,0,0,1);
	EmitVertex();

	var_texCoord0 = vec2(0.0, 1.0);
	gl_Position = sg_modelToClipping(vec4(position_ms-rightVec_ms+upVec_ms,1));
	var_normal_cs = normal_cs;
	var_vertexColor = color;
	var_position_hcs = vec4(0,0,0,1);
	EmitVertex();

	var_texCoord0 = vec2(1.0, 1.0);
	gl_Position = sg_modelToClipping(vec4(position_ms+upVec_ms + rightVec_ms,1));
	var_normal_cs = normal_cs;
	var_vertexColor = color;
	var_position_hcs = vec4(0,0,0,1);
	EmitVertex();

	EndPrimitive();
}
#endif

// ------------------
// fs
#ifdef SG_FRAGMENT_SHADER

// do nothing

struct CompositeColor {
	vec4 ambient, diffuse, specular;
};

struct SurfaceProperties {
	vec3 position_cs, normal_cs, tangent_cs;
	vec4 ambient, diffuse, specular, emission;
	float shininess;
};


//! \see main.sfn
void addFragmentEffect(in SurfaceProperties surface, inout CompositeColor color){}

#endif