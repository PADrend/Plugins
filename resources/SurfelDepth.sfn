#version 120

#ifdef SG_VERTEX_SHADER

attribute vec4 sg_Color;
attribute vec3 sg_Normal;
attribute vec3 sg_Position;

uniform mat4 sg_matrix_modelToCamera;
uniform mat4 sg_matrix_modelToClipping;
uniform mat4 sg_matrix_clippingToCamera;
uniform mat4 sg_matrix_cameraToClipping;

uniform float	sg_pointSize;
uniform int[4] sg_viewport;

uniform float depthOffset = 0.0;

varying vec3 var_normal_cs;
varying vec4 var_position_hcs;
varying vec3 var_tangent_cs;
varying vec3 var_cotangent_cs;
varying vec4 var_color;
varying float surfelRadius;

void main (void) {
	vec3 position_cs = (sg_matrix_modelToCamera * vec4(sg_Position,1.0)).xyz;
	vec3 normal_cs = normalize((sg_matrix_modelToCamera * vec4(sg_Normal,0.0)).xyz); 
  
	float d = - dot( normal_cs,  normalize(position_cs) );
  
	var_tangent_cs = normalize(dot(normal_cs,vec3(0,1,0)) > 0 ? cross(normal_cs,vec3(0,1,0)) : cross(normal_cs,vec3(1,0,0)));
	var_cotangent_cs = normalize(cross(normal_cs, var_tangent_cs));  
	var_position_hcs = vec4(position_cs,1.0);
	var_normal_cs = normal_cs; 
  var_color = sg_Color;
		
	vec4 pos_clip = sg_matrix_cameraToClipping * var_position_hcs;
	pos_clip = vec4(pos_clip.xyz / pos_clip.w, 1.0);		
	vec4 p2_clip = pos_clip + vec4(sg_pointSize / sg_viewport[2], 0, 0, 0);
	vec4 p2_cs = sg_matrix_clippingToCamera * p2_clip;
	p2_cs = vec4(p2_cs.xyz / p2_cs.w, 1);
	surfelRadius = distance(var_position_hcs, p2_cs);
	
	gl_PointSize = d > 0 ? sg_pointSize : 0;
	vec4 position_clip = sg_matrix_cameraToClipping * vec4(position_cs - vec3(0,0,depthOffset*surfelRadius),1.0);
	position_clip.z += 0.001;
	gl_Position = position_clip;
}

#endif

#ifdef SG_FRAGMENT_SHADER

varying vec3 var_normal_cs;
varying vec4 var_position_hcs;
varying vec3 var_tangent_cs;
varying vec3 var_cotangent_cs;
varying vec4 var_color;
varying float surfelRadius;

uniform int[4] sg_viewport;
uniform mat4 sg_matrix_cameraToClipping;
uniform mat4 sg_matrix_clippingToCamera;
//uniform float surfelRadius;
//uniform float depthOffset = 0.0;

void main (void) {
	vec3 position_cs = var_position_hcs.xyz / var_position_hcs.w;
	vec3 normal_cs = normalize(var_normal_cs);  
  vec4 viewport = vec4(sg_viewport[0], sg_viewport[1], sg_viewport[2], sg_viewport[3]);
	
	// transform fragment coordinates to clipping space [-1,1]x[-1,1]x[-1,1]
	vec4 frag_clip = vec4((gl_FragCoord.xy - viewport.xy) / viewport.zw * 2.0 - 1.0, -1.0, 1.0);
	// transform fragment to camera space
	vec4 frag_cs = sg_matrix_clippingToCamera * frag_clip;
	// correction of homogeneous coordinates
	frag_cs.xyz /= frag_cs.w; frag_cs.w = 1.0;

	// project fragment to surfel disc
  vec3 projected_frag_cs = frag_cs.xyz * dot(position_cs, normal_cs) / dot(frag_cs.xyz, normal_cs);
	// get projected fragment position relative to surfel origin
  vec3 rel_frag_cs = projected_frag_cs - position_cs;

	// get surfel tangent
	vec3 tangent_cs = normalize(var_tangent_cs);
	// get surfel co-tangent
	vec3 cotangent_cs = normalize(var_cotangent_cs);
	// get fragment coordinate in local surfel space
  vec2 frag_local = vec2(dot(tangent_cs, rel_frag_cs), dot(cotangent_cs, rel_frag_cs));

	// get fragment depth in camera space		
	//float depth_cs = projected_frag_cs.z - surfelRadius*depthOffset;
	
	// discard fragment if the projected fragment lies outside of the surfel disc
	if(length(frag_local) > surfelRadius )
		discard;
        
	//vec2 clipZW = depth_cs * sg_matrix_cameraToClipping[2].zw + sg_matrix_cameraToClipping[3].zw;
	//gl_FragDepth = 0.5 + 0.5 * clipZW.x / clipZW.y;
	gl_FragColor = var_color;
}

#endif
