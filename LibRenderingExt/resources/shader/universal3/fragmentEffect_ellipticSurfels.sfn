#version 140

/*
 * This file is part of the open source part of the
 * Platform for Algorithm Development and Rendering (PADrend).
 * Web page: http://www.padrend.de/
 * Copyright (C) 2014 Claudius JÃ¤hn <claudius@uni-paderborn.de>
 * Copyright (C) 2017 Sascha Brandt <myeti@mail.uni-paderborn.de>
 *
 * PADrend consists of an open source part and a proprietary part.
 * The open source part of PADrend is subject to the terms of the Mozilla
 * Public License, v. 2.0. You should have received a copy of the MPL along
 * with this library; see the file LICENSE. If not, you can obtain one at
 * http://mozilla.org/MPL/2.0/.
 */

// ------------------
// vs
#ifdef SG_VERTEX_SHADER

vec4 sg_getVertexColor();						//!	\see sgHelper.sfn
vec3 sg_getVertexTangent_ms(); //!	\see sgHelper.sfn
vec4 sg_modelToCamera(in vec4 hms); //!	\see sgHelper.sfn

struct VertexProperties {
	vec3 position_cs, normal_cs;
	float pointSize;
};

varying vec3 var_tangent_cs;
varying vec3 var_cotangent_cs;

//! \see main.sfn
void provideFragmentEffectVars(in VertexProperties vert){

	/*vec3 tangent_ms = sg_getVertexTangent_ms();
	if(length(tangent_ms) < 1) {
		var_tangent_cs = normalize(dot(vert.normal_cs,vec3(0,1,0)) > 0 ? cross(vert.normal_cs,vec3(0,1,0)) : cross(vert.normal_cs,vec3(1,0,0)));
	} else {
		var_tangent_cs = normalize(sg_modelToCamera(vec4(tangent_ms, 0.0)).xyz);
	}*/
	
	var_tangent_cs = normalize(dot(vert.normal_cs,vec3(0,1,0)) > 0 ? cross(vert.normal_cs,vec3(0,1,0)) : cross(vert.normal_cs,vec3(1,0,0)));
	var_cotangent_cs = normalize(cross(vert.normal_cs, var_tangent_cs));

}

#endif
// ------------------
// fs
#ifdef SG_FRAGMENT_SHADER

vec4 sg_cameraToClipping(in vec4 hcs);  //!	\see sgHelper.sfn
float sg_getPointSize(); //!	\see sgHelper.sfn

struct CompositeColor {
	vec4 ambient, diffuse, specular;
};

struct SurfaceProperties {
	vec3 position_cs, normal_cs, tangent_cs;
	vec4 ambient, diffuse, specular, emission;
	float shininess;
};

varying vec3 var_tangent_cs;
varying vec3 var_cotangent_cs;

uniform mat4 sg_matrix_cameraToClipping;
uniform mat4 sg_matrix_clippingToCamera;
uniform int[4] sg_viewport;
uniform float surfelRadius;
uniform bool renderSurfels;
uniform bool depthOnly = false;
uniform float depthOffset = 0.0;
uniform bool filtering = false;
uniform sampler1D t_filter;

//! \see main.sfn
void addFragmentEffect(in SurfaceProperties surface, inout CompositeColor color) {

	float depth_cs = surface.position_cs.z;

	if(renderSurfels) {
		/*
		vec2 coord = (gl_PointCoord*2.0-1.0) * vec2(1.0, -1.0);
		float dz = dot(surface.normal_cs.xy,coord) / surface.normal_cs.z;
		vec3 splat = vec3(coord.x, coord.y, dz);
		if(length(splat) > 1)
			discard;
		*/
		vec4 viewport = vec4(sg_viewport[0], sg_viewport[1], sg_viewport[2], sg_viewport[3]);

/*
		vec4 pos_clip = sg_cameraToClipping(vec4(surface.position_cs,1.0));
		pos_clip.xyz /= pos_clip.w;
		float rad_clip = sg_getPointSize() / viewport.z * 0.5;
		vec4 p2_clip = pos_clip + vec4(rad_clip, 0, pos_clip.z, 1);
		vec4 p2_cs = sg_matrix_clippingToCamera * p2_clip;
		p2_cs.xyz /= p2_cs.w;
		float surfelRadius = distance(surface.position_cs, p2_cs.xyz);*/

		// transform fragment coordinates to clipping space [-1,1]x[-1,1]x[-1,1]
		vec4 frag_clip = vec4((gl_FragCoord.xy - viewport.xy) / viewport.zw * 2.0 - 1.0, -1.0, 1.0);
		// transform fragment to camera space
		vec4 frag_cs = sg_matrix_clippingToCamera * frag_clip;
		// correction of homogeneous coordinates
		frag_cs.xyz /= frag_cs.w; frag_cs.w = 1.0;

		// project fragment to surfel disc
	  vec3 projected_frag_cs = frag_cs.xyz * dot(surface.position_cs, surface.normal_cs) / dot(frag_cs.xyz, surface.normal_cs);
		// get projected fragment position relative to surfel origin
	  vec3 rel_frag_cs = projected_frag_cs - surface.position_cs;

		// get surfel tangent
		vec3 tangent_cs = normalize(var_tangent_cs);
		// get surfel co-tangent
		vec3 cotangent_cs = normalize(var_cotangent_cs);
		// get fragment coordinate in local surfel space
	  vec2 frag_local = vec2(dot(tangent_cs, rel_frag_cs), dot(cotangent_cs, rel_frag_cs));

		// get fragment depth in camera space		
		depth_cs = projected_frag_cs.z - surfelRadius*depthOffset;
		
		// discard fragment if the projected fragment lies outside of the surfel disc
		if(length(frag_local) > surfelRadius )
			discard;
			
		color.diffuse.a = 1.0;
		if(!depthOnly && filtering) {
			color.diffuse.a = texture(t_filter, length(frag_local)/surfelRadius).r;
		}
		color.ambient.a = color.diffuse.a;
		color.specular.a = color.diffuse.a;
	} 

	vec2 clipZW = depth_cs * sg_matrix_cameraToClipping[2].zw + sg_matrix_cameraToClipping[3].zw;
	gl_FragDepth = 0.5 + 0.5 * clipZW.x / clipZW.y;
}

#endif
// ------------------
